{"version":3,"sources":["generate-matcher.js"],"names":["glob","require","pathToRegexp","querystring","headerUtils","headers","getPath","getQuery","normalizeUrl","stringMatchers","begin","targetString","url","indexOf","end","substr","length","urlRX","test","express","path","getHeaderMatcher","expectedHeaders","expectation","toLowerCase","lowerCaseHeaders","normalize","Object","keys","every","headerName","equal","getMethodMatcher","expectedMethod","method","getQueryStringMatcher","expectedQuery","query","parse","key","getParamsMatcher","expectedParams","params","matcher","Error","expectedKeys","re","replace","vals","exec","shift","reduce","map","i","name","getFunctionMatcher","functionMatcher","getUrlMatcher","route","RegExp","shorthand","expectedUrl","identifier","module","exports","matchers","filter","options","request"],"mappings":"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","sourcesContent":["const glob = require('glob-to-regexp');\nconst pathToRegexp = require('path-to-regexp');\nconst querystring = require('querystring');\nconst {\n\theaders: headerUtils,\n\tgetPath,\n\tgetQuery,\n\tnormalizeUrl\n} = require('./request-utils');\n\nconst stringMatchers = {\n\tbegin: targetString => url => url.indexOf(targetString) === 0,\n\tend: targetString => url => url.substr(-targetString.length) === targetString,\n\tglob: targetString => {\n\t\tconst urlRX = glob(targetString);\n\t\treturn url => urlRX.test(url);\n\t},\n\texpress: targetString => {\n\t\tconst urlRX = pathToRegexp(targetString);\n\t\treturn url => urlRX.test(getPath(url));\n\t},\n\tpath: targetString => url => getPath(url) === targetString\n};\n\nconst getHeaderMatcher = ({ headers: expectedHeaders }) => {\n\tconst expectation = headerUtils.toLowerCase(expectedHeaders);\n\treturn (url, { headers = {} }) => {\n\t\tconst lowerCaseHeaders = headerUtils.toLowerCase(\n\t\t\theaderUtils.normalize(headers)\n\t\t);\n\n\t\treturn Object.keys(expectation).every(headerName =>\n\t\t\theaderUtils.equal(lowerCaseHeaders[headerName], expectation[headerName])\n\t\t);\n\t};\n};\n\nconst getMethodMatcher = ({ method: expectedMethod }) => {\n\treturn (url, { method }) =>\n\t\texpectedMethod === (method ? method.toLowerCase() : 'get');\n};\n\nconst getQueryStringMatcher = ({ query: expectedQuery }) => {\n\tconst keys = Object.keys(expectedQuery);\n\treturn url => {\n\t\tconst query = querystring.parse(getQuery(url));\n\t\treturn keys.every(key => query[key] === expectedQuery[key]);\n\t};\n};\n\nconst getParamsMatcher = ({ params: expectedParams, matcher }) => {\n\tif (!/express:/.test(matcher)) {\n\t\tthrow new Error(\n\t\t\t'fetch-mock: matching on params is only possible when using an express: matcher'\n\t\t);\n\t}\n\tconst expectedKeys = Object.keys(expectedParams);\n\tconst keys = [];\n\tconst re = pathToRegexp(matcher.replace(/^express:/, ''), keys);\n\treturn url => {\n\t\tconst vals = re.exec(getPath(url)) || [];\n\t\tvals.shift();\n\t\tconst params = keys.reduce(\n\t\t\t(map, { name }, i) =>\n\t\t\t\tvals[i] ? Object.assign(map, { [name]: vals[i] }) : map,\n\t\t\t{}\n\t\t);\n\t\treturn expectedKeys.every(key => params[key] === expectedParams[key]);\n\t};\n};\n\nconst getFunctionMatcher = ({ matcher, functionMatcher = () => true }) =>\n\ttypeof matcher === 'function' ? matcher : functionMatcher;\n\nconst getUrlMatcher = route => {\n\tconst { matcher, query } = route;\n\n\tif (typeof matcher === 'function') {\n\t\treturn () => true;\n\t}\n\n\tif (matcher instanceof RegExp) {\n\t\treturn url => matcher.test(url);\n\t}\n\n\tif (matcher === '*') {\n\t\treturn () => true;\n\t}\n\n\tfor (const shorthand in stringMatchers) {\n\t\tif (matcher.indexOf(shorthand + ':') === 0) {\n\t\t\tconst url = matcher.replace(new RegExp(`^${shorthand}:`), '');\n\t\t\treturn stringMatchers[shorthand](url);\n\t\t}\n\t}\n\n\t// if none of the special syntaxes apply, it's just a simple string match\n\t// but we have to be careful to normalize the url we check and the name\n\t// of the route to allow for e.g. http://it.at.there being indistinguishable\n\t// from http://it.at.there/ once we start generating Request/Url objects\n\tconst expectedUrl = normalizeUrl(matcher);\n\tif (route.identifier === matcher) {\n\t\troute.identifier = expectedUrl;\n\t}\n\n\treturn url => {\n\t\tif (query && expectedUrl.indexOf('?')) {\n\t\t\treturn url.indexOf(expectedUrl) === 0;\n\t\t}\n\t\treturn normalizeUrl(url) === expectedUrl;\n\t};\n};\n\nmodule.exports = route => {\n\tconst matchers = [\n\t\troute.query && getQueryStringMatcher(route),\n\t\troute.method && getMethodMatcher(route),\n\t\troute.headers && getHeaderMatcher(route),\n\t\troute.params && getParamsMatcher(route),\n\t\tgetFunctionMatcher(route),\n\t\tgetUrlMatcher(route)\n\t].filter(matcher => !!matcher);\n\n\treturn (url, options = {}, request) =>\n\t\tmatchers.every(matcher => matcher(url, options, request));\n};\n"]}