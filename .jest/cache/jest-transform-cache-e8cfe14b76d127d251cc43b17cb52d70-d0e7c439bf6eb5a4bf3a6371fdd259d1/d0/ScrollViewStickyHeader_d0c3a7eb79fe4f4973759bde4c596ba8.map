{"version":3,"sources":["ScrollViewStickyHeader.js"],"names":["AnimatedImplementation","require","React","StyleSheet","View","AnimatedView","createAnimatedComponent","ScrollViewStickyHeader","state","measured","layoutY","layoutHeight","nextHeaderLayoutY","props","_onLayout","event","setState","nativeEvent","layout","y","height","onLayout","child","Children","only","children","inverted","scrollViewHeight","inputRange","outputRange","stickStartPoint","push","collisionPoint","translateY","scrollAnimatedValue","interpolate","style","styles","header","transform","cloneElement","fill","undefined","Component","create","zIndex","flex","module","exports"],"mappings":"AASA;;;;;;;;;;;;;;AAEA,IAAMA,sBAAsB,GAAGC,OAAO,CAAC,2CAAD,CAAtC;;AACA,IAAMC,KAAK,GAAGD,OAAO,CAAC,OAAD,CAArB;;AACA,IAAME,UAAU,GAAGF,OAAO,CAAC,6BAAD,CAA1B;;AACA,IAAMG,IAAI,GAAGH,OAAO,CAAC,cAAD,CAApB;;AAIA,IAAMI,YAAY,GAAGL,sBAAsB,CAACM,uBAAvB,CAA+CF,IAA/C,CAArB;;IAqBMG,sB;;;;;;;;;;;;;;;UACJC,K,GAAQ;AACNC,MAAAA,QAAQ,EAAE,KADJ;AAENC,MAAAA,OAAO,EAAE,CAFH;AAGNC,MAAAA,YAAY,EAAE,CAHR;AAINC,MAAAA,iBAAiB,EAAE,MAAKC,KAAL,CAAWD;AAJxB,K;;UAWRE,S,GAAY,UAAAC,KAAK,EAAI;AACnB,YAAKC,QAAL,CAAc;AACZP,QAAAA,QAAQ,EAAE,IADE;AAEZC,QAAAA,OAAO,EAAEK,KAAK,CAACE,WAAN,CAAkBC,MAAlB,CAAyBC,CAFtB;AAGZR,QAAAA,YAAY,EAAEI,KAAK,CAACE,WAAN,CAAkBC,MAAlB,CAAyBE;AAH3B,OAAd;;AAMA,YAAKP,KAAL,CAAWQ,QAAX,CAAoBN,KAApB;;AACA,UAAMO,KAAK,GAAGpB,KAAK,CAACqB,QAAN,CAAeC,IAAf,CAAoB,MAAKX,KAAL,CAAWY,QAA/B,CAAd;;AACA,UAAIH,KAAK,CAACT,KAAN,CAAYQ,QAAhB,EAA0B;AACxBC,QAAAA,KAAK,CAACT,KAAN,CAAYQ,QAAZ,CAAqBN,KAArB;AACD;AACF,K;;;;;;;mCAhBcI,C,EAAW;AACxB,WAAKH,QAAL,CAAc;AAACJ,QAAAA,iBAAiB,EAAEO;AAApB,OAAd;AACD;;;6BAgBQ;AAAA,wBAC8B,KAAKN,KADnC;AAAA,UACAa,QADA,eACAA,QADA;AAAA,UACUC,gBADV,eACUA,gBADV;AAAA,wBAEsD,KAAKnB,KAF3D;AAAA,UAEAC,QAFA,eAEAA,QAFA;AAAA,UAEUE,YAFV,eAEUA,YAFV;AAAA,UAEwBD,OAFxB,eAEwBA,OAFxB;AAAA,UAEiCE,iBAFjC,eAEiCA,iBAFjC;AAGP,UAAMgB,UAAyB,GAAG,CAAC,CAAC,CAAF,EAAK,CAAL,CAAlC;AACA,UAAMC,WAA0B,GAAG,CAAC,CAAD,EAAI,CAAJ,CAAnC;;AAEA,UAAIpB,QAAJ,EAAc;AACZ,YAAIiB,QAAJ,EAAc;AAeZ,cAAIC,gBAAgB,IAAI,IAAxB,EAA8B;AAC5B,gBAAMG,eAAe,GAAGpB,OAAO,GAAGC,YAAV,GAAyBgB,gBAAjD;;AACA,gBAAIG,eAAe,GAAG,CAAtB,EAAyB;AACvBF,cAAAA,UAAU,CAACG,IAAX,CAAgBD,eAAhB;AACAD,cAAAA,WAAW,CAACE,IAAZ,CAAiB,CAAjB;AACAH,cAAAA,UAAU,CAACG,IAAX,CAAgBD,eAAe,GAAG,CAAlC;AACAD,cAAAA,WAAW,CAACE,IAAZ,CAAiB,CAAjB;AAGA,kBAAMC,cAAc,GAClB,CAACpB,iBAAiB,IAAI,CAAtB,IAA2BD,YAA3B,GAA0CgB,gBAD5C;;AAEA,kBAAIK,cAAc,GAAGF,eAArB,EAAsC;AACpCF,gBAAAA,UAAU,CAACG,IAAX,CAAgBC,cAAhB,EAAgCA,cAAc,GAAG,CAAjD;AACAH,gBAAAA,WAAW,CAACE,IAAZ,CACEC,cAAc,GAAGF,eADnB,EAEEE,cAAc,GAAGF,eAFnB;AAID;AACF;AACF;AACF,SAnCD,MAmCO;AAWLF,UAAAA,UAAU,CAACG,IAAX,CAAgBrB,OAAhB;AACAmB,UAAAA,WAAW,CAACE,IAAZ,CAAiB,CAAjB;;AAGA,cAAMC,eAAc,GAAG,CAACpB,iBAAiB,IAAI,CAAtB,IAA2BD,YAAlD;;AACA,cAAIqB,eAAc,IAAItB,OAAtB,EAA+B;AAC7BkB,YAAAA,UAAU,CAACG,IAAX,CAAgBC,eAAhB,EAAgCA,eAAc,GAAG,CAAjD;AACAH,YAAAA,WAAW,CAACE,IAAZ,CAAiBC,eAAc,GAAGtB,OAAlC,EAA2CsB,eAAc,GAAGtB,OAA5D;AACD,WAHD,MAGO;AACLkB,YAAAA,UAAU,CAACG,IAAX,CAAgBrB,OAAO,GAAG,CAA1B;AACAmB,YAAAA,WAAW,CAACE,IAAZ,CAAiB,CAAjB;AACD;AACF;AACF;;AAED,UAAME,UAAU,GAAG,KAAKpB,KAAL,CAAWqB,mBAAX,CAA+BC,WAA/B,CAA2C;AAC5DP,QAAAA,UAAU,EAAVA,UAD4D;AAE5DC,QAAAA,WAAW,EAAXA;AAF4D,OAA3C,CAAnB;AAIA,UAAMP,KAAK,GAAGpB,KAAK,CAACqB,QAAN,CAAeC,IAAf,CAAoB,KAAKX,KAAL,CAAWY,QAA/B,CAAd;AAEA,aACE,oBAAC,YAAD;AACE,QAAA,WAAW,EAAE,KADf;AAEE,QAAA,QAAQ,EAAE,KAAKX,SAFjB;AAGE,QAAA,KAAK,EAAE,CAACQ,KAAK,CAACT,KAAN,CAAYuB,KAAb,EAAoBC,MAAM,CAACC,MAA3B,EAAmC;AAACC,UAAAA,SAAS,EAAE,CAAC;AAACN,YAAAA,UAAU,EAAVA;AAAD,WAAD;AAAZ,SAAnC;AAHT,SAIG/B,KAAK,CAACsC,YAAN,CAAmBlB,KAAnB,EAA0B;AACzBc,QAAAA,KAAK,EAAEC,MAAM,CAACI,IADW;AAEzBpB,QAAAA,QAAQ,EAAEqB;AAFe,OAA1B,CAJH,CADF;AAWD;;;EA/GkCxC,KAAK,CAACyC,S;;AAkH3C,IAAMN,MAAM,GAAGlC,UAAU,CAACyC,MAAX,CAAkB;AAC/BN,EAAAA,MAAM,EAAE;AACNO,IAAAA,MAAM,EAAE;AADF,GADuB;AAI/BJ,EAAAA,IAAI,EAAE;AACJK,IAAAA,IAAI,EAAE;AADF;AAJyB,CAAlB,CAAf;AASAC,MAAM,CAACC,OAAP,GAAiBzC,sBAAjB","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n'use strict';\n\nconst AnimatedImplementation = require('../../Animated/src/AnimatedImplementation');\nconst React = require('react');\nconst StyleSheet = require('../../StyleSheet/StyleSheet');\nconst View = require('../View/View');\n\nimport type {LayoutEvent} from '../../Types/CoreEventTypes';\n\nconst AnimatedView = AnimatedImplementation.createAnimatedComponent(View);\n\ntype Props = {\n  children?: React.Element<any>,\n  nextHeaderLayoutY: ?number,\n  onLayout: (event: LayoutEvent) => void,\n  scrollAnimatedValue: AnimatedImplementation.Value,\n  // Will cause sticky headers to stick at the bottom of the ScrollView instead\n  // of the top.\n  inverted: ?boolean,\n  // The height of the parent ScrollView. Currently only set when inverted.\n  scrollViewHeight: ?number,\n};\n\ntype State = {\n  measured: boolean,\n  layoutY: number,\n  layoutHeight: number,\n  nextHeaderLayoutY: ?number,\n};\n\nclass ScrollViewStickyHeader extends React.Component<Props, State> {\n  state = {\n    measured: false,\n    layoutY: 0,\n    layoutHeight: 0,\n    nextHeaderLayoutY: this.props.nextHeaderLayoutY,\n  };\n\n  setNextHeaderY(y: number) {\n    this.setState({nextHeaderLayoutY: y});\n  }\n\n  _onLayout = event => {\n    this.setState({\n      measured: true,\n      layoutY: event.nativeEvent.layout.y,\n      layoutHeight: event.nativeEvent.layout.height,\n    });\n\n    this.props.onLayout(event);\n    const child = React.Children.only(this.props.children);\n    if (child.props.onLayout) {\n      child.props.onLayout(event);\n    }\n  };\n\n  render() {\n    const {inverted, scrollViewHeight} = this.props;\n    const {measured, layoutHeight, layoutY, nextHeaderLayoutY} = this.state;\n    const inputRange: Array<number> = [-1, 0];\n    const outputRange: Array<number> = [0, 0];\n\n    if (measured) {\n      if (inverted) {\n        // The interpolation looks like:\n        // - Negative scroll: no translation\n        // - `stickStartPoint` is the point at which the header will start sticking.\n        //   It is calculated using the ScrollView viewport height so it is a the bottom.\n        // - Headers that are in the initial viewport will never stick, `stickStartPoint`\n        //   will be negative.\n        // - From 0 to `stickStartPoint` no translation. This will cause the header\n        //   to scroll normally until it reaches the top of the scroll view.\n        // - From `stickStartPoint` to when the next header y hits the bottom edge of the header: translate\n        //   equally to scroll. This will cause the header to stay at the top of the scroll view.\n        // - Past the collision with the next header y: no more translation. This will cause the\n        //   header to continue scrolling up and make room for the next sticky header.\n        //   In the case that there is no next header just translate equally to\n        //   scroll indefinitely.\n        if (scrollViewHeight != null) {\n          const stickStartPoint = layoutY + layoutHeight - scrollViewHeight;\n          if (stickStartPoint > 0) {\n            inputRange.push(stickStartPoint);\n            outputRange.push(0);\n            inputRange.push(stickStartPoint + 1);\n            outputRange.push(1);\n            // If the next sticky header has not loaded yet (probably windowing) or is the last\n            // we can just keep it sticked forever.\n            const collisionPoint =\n              (nextHeaderLayoutY || 0) - layoutHeight - scrollViewHeight;\n            if (collisionPoint > stickStartPoint) {\n              inputRange.push(collisionPoint, collisionPoint + 1);\n              outputRange.push(\n                collisionPoint - stickStartPoint,\n                collisionPoint - stickStartPoint,\n              );\n            }\n          }\n        }\n      } else {\n        // The interpolation looks like:\n        // - Negative scroll: no translation\n        // - From 0 to the y of the header: no translation. This will cause the header\n        //   to scroll normally until it reaches the top of the scroll view.\n        // - From header y to when the next header y hits the bottom edge of the header: translate\n        //   equally to scroll. This will cause the header to stay at the top of the scroll view.\n        // - Past the collision with the next header y: no more translation. This will cause the\n        //   header to continue scrolling up and make room for the next sticky header.\n        //   In the case that there is no next header just translate equally to\n        //   scroll indefinitely.\n        inputRange.push(layoutY);\n        outputRange.push(0);\n        // If the next sticky header has not loaded yet (probably windowing) or is the last\n        // we can just keep it sticked forever.\n        const collisionPoint = (nextHeaderLayoutY || 0) - layoutHeight;\n        if (collisionPoint >= layoutY) {\n          inputRange.push(collisionPoint, collisionPoint + 1);\n          outputRange.push(collisionPoint - layoutY, collisionPoint - layoutY);\n        } else {\n          inputRange.push(layoutY + 1);\n          outputRange.push(1);\n        }\n      }\n    }\n\n    const translateY = this.props.scrollAnimatedValue.interpolate({\n      inputRange,\n      outputRange,\n    });\n    const child = React.Children.only(this.props.children);\n\n    return (\n      <AnimatedView\n        collapsable={false}\n        onLayout={this._onLayout}\n        style={[child.props.style, styles.header, {transform: [{translateY}]}]}>\n        {React.cloneElement(child, {\n          style: styles.fill, // We transfer the child style to the wrapper.\n          onLayout: undefined, // we call this manually through our this._onLayout\n        })}\n      </AnimatedView>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  header: {\n    zIndex: 10,\n  },\n  fill: {\n    flex: 1,\n  },\n});\n\nmodule.exports = ScrollViewStickyHeader;\n"]}