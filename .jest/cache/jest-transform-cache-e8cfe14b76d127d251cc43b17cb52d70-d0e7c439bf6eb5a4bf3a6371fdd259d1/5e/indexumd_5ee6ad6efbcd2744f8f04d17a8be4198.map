{"version":3,"sources":["../../src/react/generic-rest.ts","../../src/react/default-props.ts","../../src/react/children.ts","../../src/react/components/debug.tsx","../../src/redux/actions.ts","../../src/redux/rx-operators.ts","../../src/guards/type-guards.ts","../../src/utils/functions.ts"],"names":["__rest","tslib_1.__assign","createElement","filter"],"mappings":"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","sourcesContent":["import { __rest } from 'tslib'\nimport { Diff } from '../types'\n\n/**\n * Use this to get properly typed {...rest} when used with generics. ( React HoC )\n *\n * @param props\n * @param pickProps\n *\n * @example\n *\n * ```tsx\n * type InjectedProps = { enableLog: boolean }\n * type Config = {...}\n *\n * const withLog = (config: Config) => <OriginalProps extends InjectedProps>(WrappedComponent: ComponentType<OriginalProps>) => {\n *\n *   type Props = OriginalProps & InjectedProps\n *\n *   return class WithLog extends Component<Props> {\n *     render(){\n *       const {enableLog, rest} = genRest<Props, InjectedProps>(this.props, ['enableLog'])\n *       return <WrappedComponent log={enableLog} {...rest} />\n *     }\n *   }\n * }\n * ```\n *\n */\nexport const pickWithRest = <\n  Props extends object = object,\n  PickedProps extends object = object,\n  Rest = { rest: Diff<Props, PickedProps> }\n>(\n  props = {} as object,\n  pickProps = [] as (keyof PickedProps)[]\n) => {\n  const rest = __rest(props, pickProps as string[])\n  const picked = pickProps.reduce(\n    // @ts-ignore\n    (acc, nextPropName) => ({ ...acc, [nextPropName]: props[nextPropName] }),\n    {}\n  )\n\n  return { ...picked, rest } as PickedProps & Rest\n}\n","import { Diff } from '../types'\n\n/**\n * @private\n */\ntype GetDefaultProps<\n  P extends object,\n  DP extends Partial<P> = Partial<P>\n> = DP & Diff<P, DP>\n\n/**\n * Identity function helper to properly resolve default and required props type annotation within Component\n *\n * @param defaultProps\n *\n * @example\n *\n * ```tsx\n * type Props = {\n *  onClick: (e: MouseEvent<HTMLElement>) => void\n *  children: ReactNode\n * } & DefaultProps<typeof defaultProps>\n *\n * const defaultProps = DefaultProps({\n *  color: 'blue' as 'blue' | 'green' | 'red',\n *  type: 'button' as 'button' | 'submit',\n * })\n * const getProps = createPropsGetter(defaultProps)\n *\n * class Button extends Component<Props> {\n *  static readonly defaultProps = defaultProps\n *  render() {\n *    const {\n *      // $ExpectType (e: MouseEvent<HTMLElement>) => void\n *      onClick: handleClick,\n *      // $ExpectType 'blue' | 'green' | 'red'\n *      color,\n *      // $ExpectType 'button' | 'submit'\n *      type,\n *      // $ExpectType ReactNode\n *      children,\n *    } = getProps(this.props)\n *\n *    return (\n *      <button onClick={handleClick} type={type} className={color}>\n *        {children}\n *      </button>\n *    )\n *  }\n * }\n * ```\n */\nexport const createPropsGetter = <DP extends Readonly<object>>(\n  _defaultProps: DP\n) => <P extends Partial<DP>>(props: P): GetDefaultProps<P, DP> => props as any\n\n/**\n * Helper to create Readonly default props\n *\n * @param props - default props object that's gonna be frozen\n *\n * @example\n *\n * ```tsx\n * // $ExpectType Readonly<{color:'blue' | 'green' | 'red', type: 'button' | 'submit'}>\n * const defaultProps = DefaultProps({\n *  color: 'blue' as 'blue' | 'green' | 'red',\n *  type: 'button' as 'button' | 'submit',\n * })\n * ```\n */\nexport const DefaultProps = <T extends object>(props: T) => Object.freeze(props)\n\n/**\n * Type alias to define defaultProps within Props intersection\n *\n * @param props default props object type annotation\n *\n * @example\n *\n * ```ts\n * // $ExpectType {onClick: (e: MouseEvent<HTMLElement>) => void, children: ReactNode, color?:'blue' | 'green' | 'red', type?: 'button' | 'submit'}\n * type Props = {\n *  onClick: (e: MouseEvent<HTMLElement>) => void\n *  children: ReactNode\n * } & DefaultProps<typeof defaultProps>\n * ```\n */\nexport type DefaultProps<T extends Readonly<object>> = Partial<T>\n","import { Children, ReactNode } from 'react'\nimport { AnyFunction } from '../types'\n\nexport const isEmptyChildren = (children: ReactNode) =>\n  Children.count(children) === 0\n\n/**\n * Checks if children is a function only ( useful for children as  a function pattern )\n * Similarly to Children.only it will throw an error if it's not a function\n *\n * @example\n *\n * ```ts\n * type Props = {\n *  userId: string\n *  children: (props:{data: UserModel}) => ReactElement\n * }\n *\n * type State = { data: UserModel | null }\n *\n * class UserRenderer extends Component<Props, State> {\n *   render(){\n *     const {data} = this.state\n *     // Will throw on runtime if children is not a function\n *     // $ExpectType (props: {data: UserModel}) => ReactElement\n *     const childrenFn = ChildrenAsFunction(children)\n *\n *     return data ? children(data) : 'Loading...'\n *   }\n *\n *   componentDidMount(){\n *     fetch(`api/users/${this.props.userId}`).json().then(data=>this.setState({data}))\n *   }\n * }\n *\n * const App = () => <UserRenderer userId={7}>\n *  { ({data}) => <div>name: {data.name}}</div> }\n * </UserRenderer>\n * ```\n */\nexport const ChildrenAsFunction = <T extends AnyFunction>(children: T) => {\n  if (typeof children !== 'function') {\n    throw new Error(\n      'React: ChildrenAsFunctionOnly expected to receive a single function as a child.'\n    )\n  }\n\n  return children\n}\n","import { createElement, ReactElement } from 'react'\n\ntype Props = {\n  children: { [key: string]: any } | string | number | boolean\n}\n\n/**\n * For debugging data within your component View\n *\n * @example\n *\n * ```tsx\n * const App = (props: {data:object}) => <div><Pre>{props.data}</Pre></div>\n * ```\n *\n */\nexport const Pre = (props: Props): ReactElement<any> => {\n  // tslint:disable-next-line:no-magic-numbers\n  return createElement('pre', {}, JSON.stringify(props.children, null, 2))\n}\n","import { Action } from './types'\n\nexport function createAction<T extends string>(type: T): Action<T>\nexport function createAction<T extends string, P>(\n  type: T,\n  payload: P\n): Action<T, P>\nexport function createAction<T extends string, P>(type: T, payload?: P) {\n  const action = payload === undefined ? { type } : { type, payload }\n\n  return action\n}\n","import { Observable, OperatorFunction } from 'rxjs'\nimport { filter } from 'rxjs/operators'\n\nimport { Action, ActionsOfType } from './types'\n\nexport function ofType<V, T1 extends string>(\n  t1: T1\n): OperatorFunction<V, ActionsOfType<V, T1>>\nexport function ofType<V, T1 extends string, T2 extends string>(\n  t1: T1,\n  t2: T2\n): OperatorFunction<V, ActionsOfType<V, T1 | T2>>\nexport function ofType<\n  V,\n  T1 extends string,\n  T2 extends string,\n  T3 extends string\n>(t1: T1, t2: T2, t3: T3): OperatorFunction<V, ActionsOfType<V, T1 | T2 | T3>>\nexport function ofType<\n  V,\n  T1 extends string,\n  T2 extends string,\n  T3 extends string,\n  T4 extends string\n>(\n  t1: T1,\n  t2: T2,\n  t3: T3,\n  t4: T4\n): OperatorFunction<V, ActionsOfType<V, T1 | T2 | T3 | T4>>\nexport function ofType<\n  V,\n  T1 extends string,\n  T2 extends string,\n  T3 extends string,\n  T4 extends string,\n  T5 extends string\n>(\n  t1: T1,\n  t2: T2,\n  t3: T3,\n  t4: T4,\n  t5: T5\n): OperatorFunction<V, ActionsOfType<V, T1 | T2 | T3 | T4 | T5>>\n\nexport function ofType(...keys: string[]) {\n  return (source: Observable<Action>) =>\n    source.pipe(filter((action) => keys.indexOf(action.type) !== -1))\n}\n","import { Maybe, NonPrimitive, Nullable } from '../types'\nimport { Bottom, Empty, NonArray } from './types'\n\nexport const isBlank = <T>(value: T): value is Nullable<T> => value == null\nexport const isPresent = <T>(value: T): value is NonNullable<T> => value != null\n// tslint:disable-next-line:ban-types\nexport const isFunction = (value: any): value is Function =>\n  typeof value === 'function'\nexport const isBoolean = (value: any): value is boolean =>\n  typeof value === 'boolean'\nexport const isString = (value: any): value is string =>\n  typeof value === 'string'\nexport const isNumber = (value: any): value is number =>\n  typeof value === 'number'\nexport const isArray = <T>(value: any): value is Array<T> =>\n  Array.isArray(value)\n\n/**\n *\n * @example\n *\n * ```ts\n * type MyMap = { who: string; age: number }\n * declare const someObj: MyMap | string | number\n *\n * if (isObject(someObj)) {\n *  // $ExpectType MyMap\n *  someObj\n * } else {\n *  // $ExpectType string | number\n *  someObj\n * }\n * ```\n */\nexport const isObject = <T extends Maybe<{}>>(\n  value: T\n): value is NonArray<NonPrimitive<NonNullable<T>>> =>\n  value != null && !Array.isArray(value) && typeof value === 'object'\n\nexport const isDate = (value: any): value is Date =>\n  value instanceof Date && !isNaN(+value)\n\nexport const isPromise = (value: any): value is PromiseLike<any> =>\n  value &&\n  typeof value.subscribe !== 'function' &&\n  typeof value.then === 'function'\n\n/**\n *\n * Checks if string OR array OR object is empty.\n * If you provide another value to check it will throw an error.\n */\nexport const isEmpty = <T extends string | object>(\n  value: T | Empty\n): value is Bottom<T> => {\n  if (isString(value) || isArray(value)) {\n    return value.length === 0\n  }\n\n  if (isObject(value)) {\n    return Object.keys(value).length === 0\n  }\n\n  throw new Error(\n    `checked value must be type of string | array | object. You provided ${\n      // tslint:disable-next-line:strict-type-predicates\n      value === null ? 'null' : typeof value\n    }`\n  )\n}\n","import { UnionFromTuple } from '../types'\n\n// tslint:disable-next-line:no-empty\nexport const noop = () => {}\nexport const identity = <T>(arg: T) => arg\n\n/**\n * Implicitly create a tuple with proper tuple types instead of widened array of union types\n *\n * @see https://stackoverflow.com/questions/49729550/implicitly-create-a-tuple-in-typescript\n *\n * @example\n * ```ts\n * // $ExpectType (string | number | boolean)[]\n * const testWidened = ['one', 1, false]\n *\n * // $ExpectType [string, number, boolean]\n * const testProperTuple = tuple('one', 1, false)\n * ```\n *\n * @param args - function arguments\n */\nexport const tuple = <T extends any[]>(...args: T): T => args\n\n/**\n * Enum function to create type safe immutable object map with runtime presence\n *\n * @param args - Enum keys\n *\n * @example\n *\n * ```ts\n * // $ExpectType Readonly<{ No: \"No\"; Yes: \"Yes\"; }>\n * const AnswerResponse = Enum('No', 'Yes')\n *\n * // $ExpectType Readonly<{ RED: \"RED\"; GREEN: \"GREEN\"; BLUE: \"BLUE\"; }>\n * const Colors = Enum('RED', 'GREEN', 'BLUE')\n * ```\n */\nexport const Enum = <T extends string[]>(...args: T) => {\n  return Object.freeze(args.reduce((acc, next) => {\n    return {\n      ...acc,\n      [next]: next,\n    }\n  }, Object.create(null)) as { [P in UnionFromTuple<typeof args>]: P })\n}\n\n/**\n * Use for getting literal type out of const myEnum = Enum(...) if you need it and export via token merge\n *\n * @example\n *\n * ```ts\n * // $ExpectType Readonly<{ No: \"No\"; Yes: \"Yes\"; }>\n * export const AnswerResponse = Enum('No', 'Yes')\n * // $ExpectType 'No' | 'Yes'\n * export type AnswerResponse = Enum(typeof AnswerResponse)\n *\n * // consumer.ts\n * import {AnswerResponse} from './enums'\n * export const respond = (recipient: string, message: AnswerResponse) => { }\n *\n * // usage.ts\n * import {respond} from './consumer'\n * import {AnswerResponse} from './enums'\n *\n * respond('Johnny 5','Yes')\n * respond('Johnny 5', AnswerResponse.No)\n * ```\n */\nexport type Enum<T extends object> = T[keyof T]\n"]}