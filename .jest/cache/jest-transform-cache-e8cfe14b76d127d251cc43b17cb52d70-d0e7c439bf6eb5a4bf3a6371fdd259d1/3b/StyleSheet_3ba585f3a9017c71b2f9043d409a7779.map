{"version":3,"sources":["StyleSheet.js"],"names":["PixelRatio","require","ReactNativeStyleAttributes","StyleSheetValidation","flatten","hairlineWidth","roundToNearestPixel","get","absoluteFill","position","left","right","top","bottom","__DEV__","Object","freeze","module","exports","absoluteFillObject","compose","style1","style2","setStyleAttributePreprocessor","property","process","value","console","error","warn","create","obj","key","validateStyle"],"mappings":"AASA;;;;;;;;;;AAEA,IAAMA,UAAU,GAAGC,OAAO,CAAC,yBAAD,CAA1B;;AACA,IAAMC,0BAA0B,GAAGD,OAAO,CAAC,+CAAD,CAA1C;;AACA,IAAME,oBAAoB,GAAGF,OAAO,CAAC,wBAAD,CAApC;;AAEA,IAAMG,OAAO,GAAGH,OAAO,CAAC,gBAAD,CAAvB;;AA0IA,IAAII,aAAa,GAAGL,UAAU,CAACM,mBAAX,CAA+B,GAA/B,CAApB;;AACA,IAAID,aAAa,KAAK,CAAtB,EAAyB;AACvBA,EAAAA,aAAa,GAAG,IAAIL,UAAU,CAACO,GAAX,EAApB;AACD;;AAED,IAAMC,YAAY,GAAG;AACnBC,EAAAA,QAAQ,EAAE,UADS;AAEnBC,EAAAA,IAAI,EAAE,CAFa;AAGnBC,EAAAA,KAAK,EAAE,CAHY;AAInBC,EAAAA,GAAG,EAAE,CAJc;AAKnBC,EAAAA,MAAM,EAAE;AALW,CAArB;;AAOA,IAAIC,OAAJ,EAAa;AACXC,EAAAA,MAAM,CAACC,MAAP,CAAcR,YAAd;AACD;;AA8CDS,MAAM,CAACC,OAAP,GAAiB;AAoBfb,EAAAA,aAAa,EAAbA,aApBe;AA2BfG,EAAAA,YAAY,EAAGA,YA3BA;AAyCfW,EAAAA,kBAAkB,EAAEX,YAzCL;AAiDfY,EAAAA,OAjDe,mBAkDbC,MAlDa,EAmDbC,MAnDa,EAoDW;AACxB,QAAID,MAAM,IAAI,IAAV,IAAkBC,MAAM,IAAI,IAAhC,EAAsC;AACpC,aAAQ,CAACD,MAAD,EAASC,MAAT,CAAR;AACD,KAFD,MAEO;AACL,aAAOD,MAAM,IAAI,IAAV,GAAiBA,MAAjB,GAA0BC,MAAjC;AACD;AACF,GA1Dc;AAmGflB,EAAAA,OAAO,EAAPA,OAnGe;AA8GfmB,EAAAA,6BA9Ge,yCA+GbC,QA/Ga,EAgHbC,OAhHa,EAiHb;AACA,QAAIC,KAAJ;;AAEA,QAAIxB,0BAA0B,CAACsB,QAAD,CAA1B,KAAyC,IAA7C,EAAmD;AACjDE,MAAAA,KAAK,GAAG,EAAR;AACD,KAFD,MAEO,IAAI,OAAOxB,0BAA0B,CAACsB,QAAD,CAAjC,KAAgD,QAApD,EAA8D;AACnEE,MAAAA,KAAK,GAAGxB,0BAA0B,CAACsB,QAAD,CAAlC;AACD,KAFM,MAEA;AACLG,MAAAA,OAAO,CAACC,KAAR,CAAiBJ,QAAjB;AACA;AACD;;AAED,QAAIV,OAAO,IAAI,OAAOY,KAAK,CAACD,OAAb,KAAyB,UAAxC,EAAoD;AAClDE,MAAAA,OAAO,CAACE,IAAR,kBAA4BL,QAA5B;AACD;;AAEDtB,IAAAA,0BAA0B,CAACsB,QAAD,CAA1B,qBAA2CE,KAA3C;AAAkDD,MAAAA,OAAO,EAAPA;AAAlD;AACD,GAlIc;AAuIfK,EAAAA,MAvIe,kBAuIiBC,GAvIjB,EAuIsD;AAInE,QAAIjB,OAAJ,EAAa;AACX,WAAK,IAAMkB,IAAX,IAAkBD,GAAlB,EAAuB;AACrB5B,QAAAA,oBAAoB,CAAC8B,aAArB,CAAmCD,IAAnC,EAAwCD,GAAxC;;AACA,YAAIA,GAAG,CAACC,IAAD,CAAP,EAAc;AACZjB,UAAAA,MAAM,CAACC,MAAP,CAAce,GAAG,CAACC,IAAD,CAAjB;AACD;AACF;AACF;;AACD,WAAOD,GAAP;AACD;AApJc,CAAjB","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n'use strict';\n\nconst PixelRatio = require('../Utilities/PixelRatio');\nconst ReactNativeStyleAttributes = require('../Components/View/ReactNativeStyleAttributes');\nconst StyleSheetValidation = require('./StyleSheetValidation');\n\nconst flatten = require('./flattenStyle');\n\nimport type {\n  ____Styles_Internal,\n  ____DangerouslyImpreciseStyle_Internal,\n  ____DangerouslyImpreciseStyleProp_Internal,\n  ____ViewStyle_Internal,\n  ____ViewStyleProp_Internal,\n  ____TextStyle_Internal,\n  ____TextStyleProp_Internal,\n  ____ImageStyle_Internal,\n  ____ImageStyleProp_Internal,\n} from './StyleSheetTypes';\n\n/**\n * This type should be used as the type for a prop that is passed through\n * to a <View>'s `style` prop. This ensures call sites of the component\n * can't pass styles that View doesn't support such as `fontSize`.`\n *\n * type Props = {style: ViewStyleProp}\n * const MyComponent = (props: Props) => <View style={props.style} />\n */\nexport type ViewStyleProp = ____ViewStyleProp_Internal;\n\n/**\n * This type should be used as the type for a prop that is passed through\n * to a <Text>'s `style` prop. This ensures call sites of the component\n * can't pass styles that Text doesn't support such as `resizeMode`.`\n *\n * type Props = {style: TextStyleProp}\n * const MyComponent = (props: Props) => <Text style={props.style} />\n */\nexport type TextStyleProp = ____TextStyleProp_Internal;\n\n/**\n * This type should be used as the type for a prop that is passed through\n * to an <Image>'s `style` prop. This ensures call sites of the component\n * can't pass styles that Image doesn't support such as `fontSize`.`\n *\n * type Props = {style: ImageStyleProp}\n * const MyComponent = (props: Props) => <Image style={props.style} />\n */\nexport type ImageStyleProp = ____ImageStyleProp_Internal;\n\n/**\n * WARNING: You probably shouldn't be using this type. This type\n * is similar to the ones above except it allows styles that are accepted\n * by all of View, Text, or Image. It is therefore very unsafe to pass this\n * through to an underlying component. Using this is almost always a mistake\n * and using one of the other more restrictive types is likely the right choice.\n */\nexport type DangerouslyImpreciseStyleProp = ____DangerouslyImpreciseStyleProp_Internal;\n\n/**\n * Utility type for getting the values for specific style keys.\n *\n * The following is bad because position is more restrictive than 'string':\n * ```\n * type Props = {position: string};\n * ```\n *\n * You should use the following instead:\n *\n * ```\n * type Props = {position: TypeForStyleKey<'position'>};\n * ```\n *\n * This will correctly give you the type 'absolute' | 'relative'\n */\nexport type TypeForStyleKey<\n  +key: $Keys<____DangerouslyImpreciseStyle_Internal>,\n> = $ElementType<____DangerouslyImpreciseStyle_Internal, key>;\n\n/**\n * This type is an object of the different possible style\n * properties that can be specified for View.\n *\n * Note that this isn't a safe way to type a style prop for a component as\n * results from StyleSheet.create return an internal identifier, not\n * an object of styles.\n *\n * If you want to type the style prop of a function,\n * consider using ViewStyleProp.\n *\n * A reasonable usage of this type is for helper functions that return an\n * object of styles to pass to a View that can't be precomputed with\n * StyleSheet.create.\n */\nexport type ViewStyle = ____ViewStyle_Internal;\n\n/**\n * This type is an object of the different possible style\n * properties that can be specified for Text.\n *\n * Note that this isn't a safe way to type a style prop for a component as\n * results from StyleSheet.create return an internal identifier, not\n * an object of styles.\n *\n * If you want to type the style prop of a function,\n * consider using TextStyleProp.\n *\n * A reasonable usage of this type is for helper functions that return an\n * object of styles to pass to a Text that can't be precomputed with\n * StyleSheet.create.\n */\nexport type TextStyle = ____TextStyle_Internal;\n\n/**\n * This type is an object of the different possible style\n * properties that can be specified for Image.\n *\n * Note that this isn't a safe way to type a style prop for a component as\n * results from StyleSheet.create return an internal identifier, not\n * an object of styles.\n *\n * If you want to type the style prop of a function,\n * consider using ImageStyleProp.\n *\n * A reasonable usage of this type is for helper functions that return an\n * object of styles to pass to an Image that can't be precomputed with\n * StyleSheet.create.\n */\nexport type ImageStyle = ____ImageStyle_Internal;\n\n/**\n * WARNING: You probably shouldn't be using this type. This type is an object\n * with all possible style keys and their values. Note that this isn't\n * a safe way to type a style prop for a component as results from\n * StyleSheet.create return an internal identifier, not an object of styles.\n *\n * If you want to type the style prop of a function, consider using\n * ViewStyleProp, TextStyleProp, or ImageStyleProp.\n *\n * This should only be used by very core utilities that operate on an object\n * containing any possible style value.\n */\nexport type DangerouslyImpreciseStyle = ____DangerouslyImpreciseStyle_Internal;\n\nlet hairlineWidth = PixelRatio.roundToNearestPixel(0.4);\nif (hairlineWidth === 0) {\n  hairlineWidth = 1 / PixelRatio.get();\n}\n\nconst absoluteFill = {\n  position: 'absolute',\n  left: 0,\n  right: 0,\n  top: 0,\n  bottom: 0,\n};\nif (__DEV__) {\n  Object.freeze(absoluteFill);\n}\n\n/**\n * A StyleSheet is an abstraction similar to CSS StyleSheets\n *\n * Create a new StyleSheet:\n *\n * ```\n * const styles = StyleSheet.create({\n *   container: {\n *     borderRadius: 4,\n *     borderWidth: 0.5,\n *     borderColor: '#d6d7da',\n *   },\n *   title: {\n *     fontSize: 19,\n *     fontWeight: 'bold',\n *   },\n *   activeTitle: {\n *     color: 'red',\n *   },\n * });\n * ```\n *\n * Use a StyleSheet:\n *\n * ```\n * <View style={styles.container}>\n *   <Text style={[styles.title, this.props.isActive && styles.activeTitle]} />\n * </View>\n * ```\n *\n * Code quality:\n *\n *  - By moving styles away from the render function, you're making the code\n *  easier to understand.\n *  - Naming the styles is a good way to add meaning to the low level components\n *  in the render function.\n *\n * Performance:\n *\n *  - Making a stylesheet from a style object makes it possible to refer to it\n * by ID instead of creating a new style object every time.\n *  - It also allows to send the style only once through the bridge. All\n * subsequent uses are going to refer an id (not implemented yet).\n */\nmodule.exports = {\n  /**\n   * This is defined as the width of a thin line on the platform. It can be\n   * used as the thickness of a border or division between two elements.\n   * Example:\n   * ```\n   *   {\n   *     borderBottomColor: '#bbb',\n   *     borderBottomWidth: StyleSheet.hairlineWidth\n   *   }\n   * ```\n   *\n   * This constant will always be a round number of pixels (so a line defined\n   * by it look crisp) and will try to match the standard width of a thin line\n   * on the underlying platform. However, you should not rely on it being a\n   * constant size, because on different platforms and screen densities its\n   * value may be calculated differently.\n   *\n   * A line with hairline width may not be visible if your simulator is downscaled.\n   */\n  hairlineWidth,\n\n  /**\n   * A very common pattern is to create overlays with position absolute and zero positioning,\n   * so `absoluteFill` can be used for convenience and to reduce duplication of these repeated\n   * styles.\n   */\n  absoluteFill: (absoluteFill: any), // TODO: This should be updated after we fix downstream Flow sites.\n\n  /**\n   * Sometimes you may want `absoluteFill` but with a couple tweaks - `absoluteFillObject` can be\n   * used to create a customized entry in a `StyleSheet`, e.g.:\n   *\n   *   const styles = StyleSheet.create({\n   *     wrapper: {\n   *       ...StyleSheet.absoluteFillObject,\n   *       top: 10,\n   *       backgroundColor: 'transparent',\n   *     },\n   *   });\n   */\n  absoluteFillObject: absoluteFill,\n\n  /**\n   * Combines two styles such that `style2` will override any styles in `style1`.\n   * If either style is falsy, the other one is returned without allocating an\n   * array, saving allocations and maintaining reference equality for\n   * PureComponent checks.\n   */\n  compose<T: DangerouslyImpreciseStyleProp>(\n    style1: ?T,\n    style2: ?T,\n  ): ?T | $ReadOnlyArray<T> {\n    if (style1 != null && style2 != null) {\n      return ([style1, style2]: $ReadOnlyArray<T>);\n    } else {\n      return style1 != null ? style1 : style2;\n    }\n  },\n\n  /**\n   * Flattens an array of style objects, into one aggregated style object.\n   * Alternatively, this method can be used to lookup IDs, returned by\n   * StyleSheet.register.\n   *\n   * > **NOTE**: Exercise caution as abusing this can tax you in terms of\n   * > optimizations.\n   * >\n   * > IDs enable optimizations through the bridge and memory in general. Refering\n   * > to style objects directly will deprive you of these optimizations.\n   *\n   * Example:\n   * ```\n   * const styles = StyleSheet.create({\n   *   listItem: {\n   *     flex: 1,\n   *     fontSize: 16,\n   *     color: 'white'\n   *   },\n   *   selectedListItem: {\n   *     color: 'green'\n   *   }\n   * });\n   *\n   * StyleSheet.flatten([styles.listItem, styles.selectedListItem])\n   * // returns { flex: 1, fontSize: 16, color: 'green' }\n   * ```\n   * Alternative use:\n   * ```\n   * StyleSheet.flatten(styles.listItem);\n   * // return { flex: 1, fontSize: 16, color: 'white' }\n   * // Simply styles.listItem would return its ID (number)\n   * ```\n   * This method internally uses `StyleSheetRegistry.getStyleByID(style)`\n   * to resolve style objects represented by IDs. Thus, an array of style\n   * objects (instances of StyleSheet.create), are individually resolved to,\n   * their respective objects, merged as one and then returned. This also explains\n   * the alternative use.\n   */\n  flatten,\n\n  /**\n   * WARNING: EXPERIMENTAL. Breaking changes will probably happen a lot and will\n   * not be reliably announced. The whole thing might be deleted, who knows? Use\n   * at your own risk.\n   *\n   * Sets a function to use to pre-process a style property value. This is used\n   * internally to process color and transform values. You should not use this\n   * unless you really know what you are doing and have exhausted other options.\n   */\n  setStyleAttributePreprocessor(\n    property: string,\n    process: (nextProp: mixed) => mixed,\n  ) {\n    let value;\n\n    if (ReactNativeStyleAttributes[property] === true) {\n      value = {};\n    } else if (typeof ReactNativeStyleAttributes[property] === 'object') {\n      value = ReactNativeStyleAttributes[property];\n    } else {\n      console.error(`${property} is not a valid style attribute`);\n      return;\n    }\n\n    if (__DEV__ && typeof value.process === 'function') {\n      console.warn(`Overwriting ${property} style attribute preprocessor`);\n    }\n\n    ReactNativeStyleAttributes[property] = {...value, process};\n  },\n\n  /**\n   * Creates a StyleSheet style reference from the given object.\n   */\n  create<+S: ____Styles_Internal>(obj: S): $ObjMap<S, (Object) => any> {\n    // TODO: This should return S as the return type. But first,\n    // we need to codemod all the callsites that are typing this\n    // return value as a number (even though it was opaque).\n    if (__DEV__) {\n      for (const key in obj) {\n        StyleSheetValidation.validateStyle(key, obj);\n        if (obj[key]) {\n          Object.freeze(obj[key]);\n        }\n      }\n    }\n    return obj;\n  },\n};\n"]}