{"version":3,"sources":["scheduler.development.js"],"names":["process","env","NODE_ENV","Object","defineProperty","exports","value","enableSchedulerDebugging","requestHostCallback","cancelHostCallback","shouldYieldToHost","unstable_now","hasNativePerformanceNow","performance","now","localDate","Date","localSetTimeout","setTimeout","undefined","localClearTimeout","clearTimeout","localRequestAnimationFrame","requestAnimationFrame","localCancelAnimationFrame","cancelAnimationFrame","ANIMATION_FRAME_TIMEOUT","rAFID","rAFTimeoutID","requestAnimationFrameWithTimeout","callback","timestamp","Performance","window","MessageChannel","_callback","_flushCallback","didTimeout","cb","ms","console","error","scheduledHostCallback","isMessageEventScheduled","timeoutTime","isAnimationFrameScheduled","isFlushingHostCallback","frameDeadline","previousFrameTime","activeFrameTime","channel","port","port2","port1","onmessage","event","prevScheduledCallback","prevTimeoutTime","currentTime","animationTick","rafTime","nextFrameTime","postMessage","absoluteTimeout","ImmediatePriority","UserBlockingPriority","NormalPriority","LowPriority","IdlePriority","maxSigned31BitInt","IMMEDIATE_PRIORITY_TIMEOUT","USER_BLOCKING_PRIORITY","NORMAL_PRIORITY_TIMEOUT","LOW_PRIORITY_TIMEOUT","IDLE_PRIORITY","firstCallbackNode","currentHostCallbackDidTimeout","isSchedulerPaused","currentPriorityLevel","currentEventStartTime","currentExpirationTime","isPerformingWork","isHostCallbackScheduled","scheduleHostCallbackIfNeeded","expirationTime","flushWork","flushFirstCallback","currentlyFlushingCallback","next","lastCallbackNode","previous","priorityLevel","previousPriorityLevel","previousExpirationTime","continuationCallback","didUserCallbackTimeout","continuationNode","nextAfterContinuation","node","previousDidTimeout","unstable_runWithPriority","eventHandler","previousEventStartTime","unstable_next","unstable_wrapCallback","parentPriorityLevel","apply","arguments","unstable_scheduleCallback","deprecated_options","startTime","timeout","newNode","unstable_pauseExecution","unstable_continueExecution","unstable_getFirstCallbackNode","unstable_cancelCallback","callbackNode","unstable_getCurrentPriorityLevel","unstable_shouldYield","unstable_ImmediatePriority","unstable_UserBlockingPriority","unstable_NormalPriority","unstable_IdlePriority","unstable_LowPriority"],"mappings":"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","sourcesContent":["/** @license React v0.14.0\n * scheduler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar enableSchedulerDebugging = false;\n\n// The DOM Scheduler implementation is similar to requestIdleCallback. It\n// works by scheduling a requestAnimationFrame, storing the time for the start\n// of the frame, then scheduling a postMessage which gets scheduled after paint.\n// Within the postMessage handler do as much work as possible until time + frame\n// rate. By separating the idle call into a separate event tick we ensure that\n// layout, paint and other browser work is counted against the available time.\n// The frame rate is dynamically adjusted.\n\nvar requestHostCallback = void 0;\nvar cancelHostCallback = void 0;\nvar shouldYieldToHost = void 0;\nexports.unstable_now = void 0;\n\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n\n// We capture a local reference to any global, in case it gets polyfilled after\n// this module is initially evaluated. We want to be using a\n// consistent implementation.\nvar localDate = Date;\n\n// This initialization code may run even on server environments if a component\n// just imports ReactDOM (e.g. for findDOMNode). Some environments might not\n// have setTimeout or clearTimeout. However, we always expect them to be defined\n// on the client. https://github.com/facebook/react/pull/13088\nvar localSetTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;\nvar localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;\n\n// We don't expect either of these to necessarily be defined, but we will error\n// later if they are missing on the client.\nvar localRequestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : undefined;\nvar localCancelAnimationFrame = typeof cancelAnimationFrame === 'function' ? cancelAnimationFrame : undefined;\n\n// requestAnimationFrame does not run when the tab is in the background. If\n// we're backgrounded we prefer for that work to happen so that the page\n// continues to load in the background. So we also schedule a 'setTimeout' as\n// a fallback.\n// TODO: Need a better heuristic for backgrounded work.\nvar ANIMATION_FRAME_TIMEOUT = 100;\nvar rAFID = void 0;\nvar rAFTimeoutID = void 0;\nvar requestAnimationFrameWithTimeout = function (callback) {\n  // schedule rAF and also a setTimeout\n  rAFID = localRequestAnimationFrame(function (timestamp) {\n    // cancel the setTimeout\n    localClearTimeout(rAFTimeoutID);\n    callback(timestamp);\n  });\n  rAFTimeoutID = localSetTimeout(function () {\n    // cancel the requestAnimationFrame\n    localCancelAnimationFrame(rAFID);\n    callback(exports.unstable_now());\n  }, ANIMATION_FRAME_TIMEOUT);\n};\n\nif (hasNativePerformanceNow) {\n  var Performance = performance;\n  exports.unstable_now = function () {\n    return Performance.now();\n  };\n} else {\n  exports.unstable_now = function () {\n    return localDate.now();\n  };\n}\n\nif (\n// If Scheduler runs in a non-DOM environment, it falls back to a naive\n// implementation using setTimeout.\ntypeof window === 'undefined' ||\n// Check if MessageChannel is supported, too.\ntypeof MessageChannel !== 'function') {\n  // If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore,\n  // fallback to a naive implementation.\n  var _callback = null;\n  var _flushCallback = function (didTimeout) {\n    if (_callback !== null) {\n      try {\n        _callback(didTimeout);\n      } finally {\n        _callback = null;\n      }\n    }\n  };\n  requestHostCallback = function (cb, ms) {\n    if (_callback !== null) {\n      // Protect against re-entrancy.\n      setTimeout(requestHostCallback, 0, cb);\n    } else {\n      _callback = cb;\n      setTimeout(_flushCallback, 0, false);\n    }\n  };\n  cancelHostCallback = function () {\n    _callback = null;\n  };\n  shouldYieldToHost = function () {\n    return false;\n  };\n} else {\n  if (typeof console !== 'undefined') {\n    // TODO: Remove fb.me link\n    if (typeof localRequestAnimationFrame !== 'function') {\n      console.error(\"This browser doesn't support requestAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n    }\n    if (typeof localCancelAnimationFrame !== 'function') {\n      console.error(\"This browser doesn't support cancelAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n    }\n  }\n\n  var scheduledHostCallback = null;\n  var isMessageEventScheduled = false;\n  var timeoutTime = -1;\n\n  var isAnimationFrameScheduled = false;\n\n  var isFlushingHostCallback = false;\n\n  var frameDeadline = 0;\n  // We start out assuming that we run at 30fps but then the heuristic tracking\n  // will adjust this value to a faster fps if we get more frequent animation\n  // frames.\n  var previousFrameTime = 33;\n  var activeFrameTime = 33;\n\n  shouldYieldToHost = function () {\n    return frameDeadline <= exports.unstable_now();\n  };\n\n  // We use the postMessage trick to defer idle work until after the repaint.\n  var channel = new MessageChannel();\n  var port = channel.port2;\n  channel.port1.onmessage = function (event) {\n    isMessageEventScheduled = false;\n\n    var prevScheduledCallback = scheduledHostCallback;\n    var prevTimeoutTime = timeoutTime;\n    scheduledHostCallback = null;\n    timeoutTime = -1;\n\n    var currentTime = exports.unstable_now();\n\n    var didTimeout = false;\n    if (frameDeadline - currentTime <= 0) {\n      // There's no time left in this idle period. Check if the callback has\n      // a timeout and whether it's been exceeded.\n      if (prevTimeoutTime !== -1 && prevTimeoutTime <= currentTime) {\n        // Exceeded the timeout. Invoke the callback even though there's no\n        // time left.\n        didTimeout = true;\n      } else {\n        // No timeout.\n        if (!isAnimationFrameScheduled) {\n          // Schedule another animation callback so we retry later.\n          isAnimationFrameScheduled = true;\n          requestAnimationFrameWithTimeout(animationTick);\n        }\n        // Exit without invoking the callback.\n        scheduledHostCallback = prevScheduledCallback;\n        timeoutTime = prevTimeoutTime;\n        return;\n      }\n    }\n\n    if (prevScheduledCallback !== null) {\n      isFlushingHostCallback = true;\n      try {\n        prevScheduledCallback(didTimeout);\n      } finally {\n        isFlushingHostCallback = false;\n      }\n    }\n  };\n\n  var animationTick = function (rafTime) {\n    if (scheduledHostCallback !== null) {\n      // Eagerly schedule the next animation callback at the beginning of the\n      // frame. If the scheduler queue is not empty at the end of the frame, it\n      // will continue flushing inside that callback. If the queue *is* empty,\n      // then it will exit immediately. Posting the callback at the start of the\n      // frame ensures it's fired within the earliest possible frame. If we\n      // waited until the end of the frame to post the callback, we risk the\n      // browser skipping a frame and not firing the callback until the frame\n      // after that.\n      requestAnimationFrameWithTimeout(animationTick);\n    } else {\n      // No pending work. Exit.\n      isAnimationFrameScheduled = false;\n      return;\n    }\n\n    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\n      if (nextFrameTime < 8) {\n        // Defensive coding. We don't support higher frame rates than 120hz.\n        // If the calculated frame time gets lower than 8, it is probably a bug.\n        nextFrameTime = 8;\n      }\n      // If one frame goes long, then the next one can be short to catch up.\n      // If two frames are short in a row, then that's an indication that we\n      // actually have a higher frame rate than what we're currently optimizing.\n      // We adjust our heuristic dynamically accordingly. For example, if we're\n      // running on 120hz display or 90hz VR display.\n      // Take the max of the two in case one of them was an anomaly due to\n      // missed frame deadlines.\n      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n    } else {\n      previousFrameTime = nextFrameTime;\n    }\n    frameDeadline = rafTime + activeFrameTime;\n    if (!isMessageEventScheduled) {\n      isMessageEventScheduled = true;\n      port.postMessage(undefined);\n    }\n  };\n\n  requestHostCallback = function (callback, absoluteTimeout) {\n    scheduledHostCallback = callback;\n    timeoutTime = absoluteTimeout;\n    if (isFlushingHostCallback || absoluteTimeout < 0) {\n      // Don't wait for the next frame. Continue working ASAP, in a new event.\n      port.postMessage(undefined);\n    } else if (!isAnimationFrameScheduled) {\n      // If rAF didn't already schedule one, we need to schedule a frame.\n      // TODO: If this rAF doesn't materialize because the browser throttles, we\n      // might want to still have setTimeout trigger rIC as a backup to ensure\n      // that we keep performing work.\n      isAnimationFrameScheduled = true;\n      requestAnimationFrameWithTimeout(animationTick);\n    }\n  };\n\n  cancelHostCallback = function () {\n    scheduledHostCallback = null;\n    isMessageEventScheduled = false;\n    timeoutTime = -1;\n  };\n}\n\n/* eslint-disable no-var */\n\n// TODO: Use symbols?\nvar ImmediatePriority = 1;\nvar UserBlockingPriority = 2;\nvar NormalPriority = 3;\nvar LowPriority = 4;\nvar IdlePriority = 5;\n\n// Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n// Math.pow(2, 30) - 1\n// 0b111111111111111111111111111111\nvar maxSigned31BitInt = 1073741823;\n\n// Times out immediately\nvar IMMEDIATE_PRIORITY_TIMEOUT = -1;\n// Eventually times out\nvar USER_BLOCKING_PRIORITY = 250;\nvar NORMAL_PRIORITY_TIMEOUT = 5000;\nvar LOW_PRIORITY_TIMEOUT = 10000;\n// Never times out\nvar IDLE_PRIORITY = maxSigned31BitInt;\n\n// Callbacks are stored as a circular, doubly linked list.\nvar firstCallbackNode = null;\n\nvar currentHostCallbackDidTimeout = false;\n// Pausing the scheduler is useful for debugging.\nvar isSchedulerPaused = false;\n\nvar currentPriorityLevel = NormalPriority;\nvar currentEventStartTime = -1;\nvar currentExpirationTime = -1;\n\n// This is set while performing work, to prevent re-entrancy.\nvar isPerformingWork = false;\n\nvar isHostCallbackScheduled = false;\n\nfunction scheduleHostCallbackIfNeeded() {\n  if (isPerformingWork) {\n    // Don't schedule work yet; wait until the next time we yield.\n    return;\n  }\n  if (firstCallbackNode !== null) {\n    // Schedule the host callback using the earliest expiration in the list.\n    var expirationTime = firstCallbackNode.expirationTime;\n    if (isHostCallbackScheduled) {\n      // Cancel the existing host callback.\n      cancelHostCallback();\n    } else {\n      isHostCallbackScheduled = true;\n    }\n    requestHostCallback(flushWork, expirationTime);\n  }\n}\n\nfunction flushFirstCallback() {\n  var currentlyFlushingCallback = firstCallbackNode;\n\n  // Remove the node from the list before calling the callback. That way the\n  // list is in a consistent state even if the callback throws.\n  var next = firstCallbackNode.next;\n  if (firstCallbackNode === next) {\n    // This is the last callback in the list.\n    firstCallbackNode = null;\n    next = null;\n  } else {\n    var lastCallbackNode = firstCallbackNode.previous;\n    firstCallbackNode = lastCallbackNode.next = next;\n    next.previous = lastCallbackNode;\n  }\n\n  currentlyFlushingCallback.next = currentlyFlushingCallback.previous = null;\n\n  // Now it's safe to call the callback.\n  var callback = currentlyFlushingCallback.callback;\n  var expirationTime = currentlyFlushingCallback.expirationTime;\n  var priorityLevel = currentlyFlushingCallback.priorityLevel;\n  var previousPriorityLevel = currentPriorityLevel;\n  var previousExpirationTime = currentExpirationTime;\n  currentPriorityLevel = priorityLevel;\n  currentExpirationTime = expirationTime;\n  var continuationCallback;\n  try {\n    var didUserCallbackTimeout = currentHostCallbackDidTimeout ||\n    // Immediate priority callbacks are always called as if they timed out\n    priorityLevel === ImmediatePriority;\n    continuationCallback = callback(didUserCallbackTimeout);\n  } catch (error) {\n    throw error;\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n    currentExpirationTime = previousExpirationTime;\n  }\n\n  // A callback may return a continuation. The continuation should be scheduled\n  // with the same priority and expiration as the just-finished callback.\n  if (typeof continuationCallback === 'function') {\n    var continuationNode = {\n      callback: continuationCallback,\n      priorityLevel: priorityLevel,\n      expirationTime: expirationTime,\n      next: null,\n      previous: null\n    };\n\n    // Insert the new callback into the list, sorted by its expiration. This is\n    // almost the same as the code in `scheduleCallback`, except the callback\n    // is inserted into the list *before* callbacks of equal expiration instead\n    // of after.\n    if (firstCallbackNode === null) {\n      // This is the first callback in the list.\n      firstCallbackNode = continuationNode.next = continuationNode.previous = continuationNode;\n    } else {\n      var nextAfterContinuation = null;\n      var node = firstCallbackNode;\n      do {\n        if (node.expirationTime >= expirationTime) {\n          // This callback expires at or after the continuation. We will insert\n          // the continuation *before* this callback.\n          nextAfterContinuation = node;\n          break;\n        }\n        node = node.next;\n      } while (node !== firstCallbackNode);\n\n      if (nextAfterContinuation === null) {\n        // No equal or lower priority callback was found, which means the new\n        // callback is the lowest priority callback in the list.\n        nextAfterContinuation = firstCallbackNode;\n      } else if (nextAfterContinuation === firstCallbackNode) {\n        // The new callback is the highest priority callback in the list.\n        firstCallbackNode = continuationNode;\n        scheduleHostCallbackIfNeeded();\n      }\n\n      var previous = nextAfterContinuation.previous;\n      previous.next = nextAfterContinuation.previous = continuationNode;\n      continuationNode.next = nextAfterContinuation;\n      continuationNode.previous = previous;\n    }\n  }\n}\n\nfunction flushWork(didUserCallbackTimeout) {\n  // Exit right away if we're currently paused\n  if (enableSchedulerDebugging && isSchedulerPaused) {\n    return;\n  }\n\n  // We'll need a new host callback the next time work is scheduled.\n  isHostCallbackScheduled = false;\n\n  isPerformingWork = true;\n  var previousDidTimeout = currentHostCallbackDidTimeout;\n  currentHostCallbackDidTimeout = didUserCallbackTimeout;\n  try {\n    if (didUserCallbackTimeout) {\n      // Flush all the expired callbacks without yielding.\n      while (firstCallbackNode !== null && !(enableSchedulerDebugging && isSchedulerPaused)) {\n        // TODO Wrap in feature flag\n        // Read the current time. Flush all the callbacks that expire at or\n        // earlier than that time. Then read the current time again and repeat.\n        // This optimizes for as few performance.now calls as possible.\n        var currentTime = exports.unstable_now();\n        if (firstCallbackNode.expirationTime <= currentTime) {\n          do {\n            flushFirstCallback();\n          } while (firstCallbackNode !== null && firstCallbackNode.expirationTime <= currentTime && !(enableSchedulerDebugging && isSchedulerPaused));\n          continue;\n        }\n        break;\n      }\n    } else {\n      // Keep flushing callbacks until we run out of time in the frame.\n      if (firstCallbackNode !== null) {\n        do {\n          if (enableSchedulerDebugging && isSchedulerPaused) {\n            break;\n          }\n          flushFirstCallback();\n        } while (firstCallbackNode !== null && !shouldYieldToHost());\n      }\n    }\n  } finally {\n    isPerformingWork = false;\n    currentHostCallbackDidTimeout = previousDidTimeout;\n    // There's still work remaining. Request another callback.\n    scheduleHostCallbackIfNeeded();\n  }\n}\n\nfunction unstable_runWithPriority(priorityLevel, eventHandler) {\n  switch (priorityLevel) {\n    case ImmediatePriority:\n    case UserBlockingPriority:\n    case NormalPriority:\n    case LowPriority:\n    case IdlePriority:\n      break;\n    default:\n      priorityLevel = NormalPriority;\n  }\n\n  var previousPriorityLevel = currentPriorityLevel;\n  var previousEventStartTime = currentEventStartTime;\n  currentPriorityLevel = priorityLevel;\n  currentEventStartTime = exports.unstable_now();\n\n  try {\n    return eventHandler();\n  } catch (error) {\n    // There's still work remaining. Request another callback.\n    scheduleHostCallbackIfNeeded();\n    throw error;\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n    currentEventStartTime = previousEventStartTime;\n  }\n}\n\nfunction unstable_next(eventHandler) {\n  var priorityLevel = void 0;\n  switch (currentPriorityLevel) {\n    case ImmediatePriority:\n    case UserBlockingPriority:\n    case NormalPriority:\n      // Shift down to normal priority\n      priorityLevel = NormalPriority;\n      break;\n    default:\n      // Anything lower than normal priority should remain at the current level.\n      priorityLevel = currentPriorityLevel;\n      break;\n  }\n\n  var previousPriorityLevel = currentPriorityLevel;\n  var previousEventStartTime = currentEventStartTime;\n  currentPriorityLevel = priorityLevel;\n  currentEventStartTime = exports.unstable_now();\n\n  try {\n    return eventHandler();\n  } catch (error) {\n    // There's still work remaining. Request another callback.\n    scheduleHostCallbackIfNeeded();\n    throw error;\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n    currentEventStartTime = previousEventStartTime;\n  }\n}\n\nfunction unstable_wrapCallback(callback) {\n  var parentPriorityLevel = currentPriorityLevel;\n  return function () {\n    // This is a fork of runWithPriority, inlined for performance.\n    var previousPriorityLevel = currentPriorityLevel;\n    var previousEventStartTime = currentEventStartTime;\n    currentPriorityLevel = parentPriorityLevel;\n    currentEventStartTime = exports.unstable_now();\n\n    try {\n      return callback.apply(this, arguments);\n    } catch (error) {\n      // There's still work remaining. Request another callback.\n      scheduleHostCallbackIfNeeded();\n      throw error;\n    } finally {\n      currentPriorityLevel = previousPriorityLevel;\n      currentEventStartTime = previousEventStartTime;\n    }\n  };\n}\n\nfunction unstable_scheduleCallback(priorityLevel, callback, deprecated_options) {\n  var startTime = currentEventStartTime !== -1 ? currentEventStartTime : exports.unstable_now();\n\n  var expirationTime;\n  if (typeof deprecated_options === 'object' && deprecated_options !== null && typeof deprecated_options.timeout === 'number') {\n    // FIXME: Remove this branch once we lift expiration times out of React.\n    expirationTime = startTime + deprecated_options.timeout;\n  } else {\n    switch (priorityLevel) {\n      case ImmediatePriority:\n        expirationTime = startTime + IMMEDIATE_PRIORITY_TIMEOUT;\n        break;\n      case UserBlockingPriority:\n        expirationTime = startTime + USER_BLOCKING_PRIORITY;\n        break;\n      case IdlePriority:\n        expirationTime = startTime + IDLE_PRIORITY;\n        break;\n      case LowPriority:\n        expirationTime = startTime + LOW_PRIORITY_TIMEOUT;\n        break;\n      case NormalPriority:\n      default:\n        expirationTime = startTime + NORMAL_PRIORITY_TIMEOUT;\n    }\n  }\n\n  var newNode = {\n    callback: callback,\n    priorityLevel: priorityLevel,\n    expirationTime: expirationTime,\n    next: null,\n    previous: null\n  };\n\n  // Insert the new callback into the list, ordered first by expiration, then\n  // by insertion. So the new callback is inserted any other callback with\n  // equal expiration.\n  if (firstCallbackNode === null) {\n    // This is the first callback in the list.\n    firstCallbackNode = newNode.next = newNode.previous = newNode;\n    scheduleHostCallbackIfNeeded();\n  } else {\n    var next = null;\n    var node = firstCallbackNode;\n    do {\n      if (node.expirationTime > expirationTime) {\n        // The new callback expires before this one.\n        next = node;\n        break;\n      }\n      node = node.next;\n    } while (node !== firstCallbackNode);\n\n    if (next === null) {\n      // No callback with a later expiration was found, which means the new\n      // callback has the latest expiration in the list.\n      next = firstCallbackNode;\n    } else if (next === firstCallbackNode) {\n      // The new callback has the earliest expiration in the entire list.\n      firstCallbackNode = newNode;\n      scheduleHostCallbackIfNeeded();\n    }\n\n    var previous = next.previous;\n    previous.next = next.previous = newNode;\n    newNode.next = next;\n    newNode.previous = previous;\n  }\n\n  return newNode;\n}\n\nfunction unstable_pauseExecution() {\n  isSchedulerPaused = true;\n}\n\nfunction unstable_continueExecution() {\n  isSchedulerPaused = false;\n  if (firstCallbackNode !== null) {\n    scheduleHostCallbackIfNeeded();\n  }\n}\n\nfunction unstable_getFirstCallbackNode() {\n  return firstCallbackNode;\n}\n\nfunction unstable_cancelCallback(callbackNode) {\n  var next = callbackNode.next;\n  if (next === null) {\n    // Already cancelled.\n    return;\n  }\n\n  if (next === callbackNode) {\n    // This is the only scheduled callback. Clear the list.\n    firstCallbackNode = null;\n  } else {\n    // Remove the callback from its position in the list.\n    if (callbackNode === firstCallbackNode) {\n      firstCallbackNode = next;\n    }\n    var previous = callbackNode.previous;\n    previous.next = next;\n    next.previous = previous;\n  }\n\n  callbackNode.next = callbackNode.previous = null;\n}\n\nfunction unstable_getCurrentPriorityLevel() {\n  return currentPriorityLevel;\n}\n\nfunction unstable_shouldYield() {\n  return !currentHostCallbackDidTimeout && (firstCallbackNode !== null && firstCallbackNode.expirationTime < currentExpirationTime || shouldYieldToHost());\n}\n\nexports.unstable_ImmediatePriority = ImmediatePriority;\nexports.unstable_UserBlockingPriority = UserBlockingPriority;\nexports.unstable_NormalPriority = NormalPriority;\nexports.unstable_IdlePriority = IdlePriority;\nexports.unstable_LowPriority = LowPriority;\nexports.unstable_runWithPriority = unstable_runWithPriority;\nexports.unstable_next = unstable_next;\nexports.unstable_scheduleCallback = unstable_scheduleCallback;\nexports.unstable_cancelCallback = unstable_cancelCallback;\nexports.unstable_wrapCallback = unstable_wrapCallback;\nexports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\nexports.unstable_shouldYield = unstable_shouldYield;\nexports.unstable_continueExecution = unstable_continueExecution;\nexports.unstable_pauseExecution = unstable_pauseExecution;\nexports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\n  })();\n}\n"]}